import java.util.*;
import fi.tkk.cs.tkkcc.slx.*;

COMPILER Compiler

public SymbolTable st;
// public CodeGenerator gen;
public SlxProgram slx;

private Printer printer;
private int label_counter = 0;
private int MAIN_LABEL = -1;


/*----------------------------------------------------------------------------*
 * Helper functions:                                                          *
 * Raises an error in case of incompatible types                              *
 *----------------------------------------------------------------------------*/

private void checkBoolean(int type, String operation) {
  if (type != st.BOOLEAN) SemErr("type error: " +
                                 operation +
                                 " expects boolean type, got " +
                                 SymbolTable.TYPES_INVERSE.get(type));
}

private void checkInt(int type, String operation) {
  if (type != st.INTEGER) SemErr("type error: " +
                                 operation +
                                 " expects integer type, got " +
                                 SymbolTable.TYPES_INVERSE.get(type));
}

private void checkArrayType(int type, String operation) {
  if (type != st.INTEGER_ARRAY) SemErr("type error: " +
                                       operation +
                                       "expects integer array type, got " +
                                       SymbolTable.TYPES_INVERSE.get(type));
}

private void checkCallParameterTypes(SymbolTable.Function fn, ArrayList<Integer> parameters) {
  ArrayList<Integer> expected_types = new ArrayList<Integer>();
  for (int i=0; i<fn.parameters.size(); i++) {
    expected_types.add(fn.parameters.get(i).type);
  }

  int expected_count = expected_types.size();
  int parameter_count = parameters.size();

  if (expected_count != parameter_count) {
    SemErr("argument count error: function " +
           fn.name +
           " expects " +
           expected_count +
           " arguments, got " +
           parameter_count);
  }

  for (int i=0; i<expected_count; i++) {
    if (expected_types.get(i) != parameters.get(i)) {
      SemErr("type error: function " +
               fn.name +
               " parameter at position " +
               i +
               " should be " +
               SymbolTable.TYPES_INVERSE.get(expected_types.get(i)) +
               " got " +
               SymbolTable.TYPES_INVERSE.get(parameters.get(i)));
    }
  }
}

private void checkReturnType(SymbolTable.Function fn, int type) {
  if (fn.type == type) return;

  SemErr("type error: return type of function " +
         fn.name +
         " is " +
         SymbolTable.TYPES_INVERSE.get(fn.type) +
         ", got " +
         SymbolTable.TYPES_INVERSE.get(type) +
         " instead");
}

private void checkAssignmentType(int expected, int type) {
  if (expected == type) return;

  SemErr("incompatible types: trying to assign " +
         SymbolTable.TYPES_INVERSE.get(type) +
         " value to " +
         SymbolTable.TYPES_INVERSE.get(expected) +
         " variable");
}

/*----------------------------------------------------------------------------*
 * Functions to resolve LL(1) conflicts:                                      *
 * Used as IF ( ... ) in expressions.                                         *
 *--------------------------------------------------------------------------- */

private boolean isFunctionCall() {
  scanner.ResetPeek();
  return (la.kind == _identifier && scanner.Peek().kind == _lpar);
}

private boolean isLengthAccess() {
  scanner.ResetPeek();
  return (la.kind == _identifier && scanner.Peek().kind == _dot);
}

/*----------------------------------------------------------------------------*
 * Functions to keep the code cleaner                                         *
 *----------------------------------------------------------------------------*/
private SymbolTable.Function newFunction(String name, int type) {
  SymbolTable.Function fn = st.addFunction(name, type, label_counter++);
  slx.emit(CommandWord.LAB, fn.label);
  st.openScope(fn.type);
  // Address of the scope?
  return fn;
}

private void functionReturn() {
  if (st.top_scope.index == 1) slx.emit(CommandWord.RET);
  return;
}

private int safeParseInt(String val) {
  try {
    return Integer.parseInt(val);
  } catch (NumberFormatException e) {
    SemErr("too large integer");
    return Integer.MAX_VALUE;
  }
}

/*----------------------------------------------------------------------------*
 * Weird 'struct' for passing the IdAccess data.                              *
 * This might neither be a good practice in Java, nor a good way to pass the  *
 * IdAccess data. However this feels the most intuitive right now.            *
 *----------------------------------------------------------------------------*/
private class IdAccessData {
  public boolean local; // 'local' or 'dynamic'
  public SymbolTable.Variable var; // The variable in question
}


CHARACTERS
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.

  zero          = '0'.
  nonZeroDigit  = "123456789".
  digit         = zero + nonZeroDigit .
  letter        = 'A' .. 'Z' + 'a' .. 'z' + '_' + '$'.

  char          = ANY - "'" - '\\' - cr - lf.
  stringChar    = ANY - "\"" - '\\' - cr - lf.

TOKENS
  identifier    = letter { letter | digit }.
  integer       = digit { digit }.

  colon   = ":".
  comma   = ",".
  dec     = "--".
  dot     = ".".
  inc     = "++".
  lbrace  = "{".
  lbrack  = "[".
  lpar    = "(".
  minus   = "-".
  not     = "!".
  plus    = "+".
  rbrace  = "}".
  rbrack  = "]".
  rpar    = ")".
  tilde   = "~".

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

PRODUCTIONS

/*----------------------------------------------------------------------------*/

Compiler                               (. st.openScope(st.UNDEFINED); .)
= FuncDecl
  MainFuncDecl                         (.
                                          slx.emit(CommandWord.HLT);
                                          st.closeScope();
                                       .)
.

/*----------------------------------------------------------------------------*/

MainFuncDecl                           (. st.openScope(st.UNDEFINED); int return_type; .)
= "main"                               (. slx.emit(CommandWord.LAB, MAIN_LABEL); .)
  FuncBody<out return_type>
.

/*----------------------------------------------------------------------------*/

FuncDecl                                (. slx.emit(CommandWord.JMP, MAIN_LABEL); .)
=
{                                       (. int return_type; SymbolTable.Function fn; .)
  FuncHeader<out fn>
  FuncBody<out return_type>             (. checkReturnType(fn, return_type); .)
}
.

/*----------------------------------------------------------------------------*/

FuncHeader<out SymbolTable.Function fn> (. int type; .)
= Type<out type> identifier             (. fn = newFunction(t.val, type); .)
  '(' ParamList<fn> ')'                 // newFunction opens new scope
.

/*----------------------------------------------------------------------------*/

ParamList<SymbolTable.Function fn>      (. String name; int type; SymbolTable.Variable var; .)
=
[ Type<out type> Ident<out name>        (.
                                           var = st.addVariable(name, type);
                                           fn.addParameter(var);
                                        .)
{ ',' Type<out type> Ident<out name>    (.
                                           var = st.addVariable(name, type);
                                           fn.addParameter(var);
                                        .)
}
]
.

/*----------------------------------------------------------------------------*/

FuncBody<out int return_type>
= "begin"
  VarDecl
  StatementList
  ReturnStatement<out return_type>
  "end"                                 (. st.closeScope(); .)
.

/*----------------------------------------------------------------------------*/

VarDecl                                 (. String name; int type; .)
=
{ Type<out type>
  Ident<out name>                       (. st.addVariable(name, type); .)
  ';'
}                                       // TODO: check the frame size?
.

/*----------------------------------------------------------------------------*/

ReturnStatement<out int type>
= "return"
  Expr<out type>
  ";"                                    (. functionReturn(); .)
.

/*----------------------------------------------------------------------------*/

StatementList
= { Statement }
.

/*----------------------------------------------------------------------------*/

Statement
=                                         (. int type, if_end; .)
  "if" '(' Expr<out type> ')'             (.
                                             checkBoolean(type, "if statement");
                                             if_end   = label_counter++;
                                             slx.emit(CommandWord.JZE, if_end);
                                          .)
  "then" Statement                        (. slx.emit(CommandWord.LAB, if_end); .)
|                                         (. int type, while_start; .)
  "do"                                    (.
                                             while_start = label_counter++;
                                             slx.emit(CommandWord.LAB, while_start);
                                          .)
  Statement
  "while" '('
  Expr<out type>                          (.
                                             checkBoolean(type, "while condition");
                                             // we don't have jump if command word,
                                             // so need to negate and use jump if not
                                             slx.emit(CommandWord.NOT);
                                             slx.emit(CommandWord.JZE, while_start);
                                          .)
  ')' ';'
|                                         (. int type; .)
  "print" '(' Expr<out type> ')' ';'      (. slx.emit(CommandWord.WRI); .)
| "begin" StatementList "end"
|                                         (. int type, expected; CommandWord cw; .)
  IdAccess<out IdAccessData data>
  '='                                     //(. slx.emit(CommandWord.ENT, var.adr); .)
                                          // cannot assign to procedure
  Expr<out type>                          (.
                                             expected = data.local ? data.var.type : st.INTEGER;
                                             checkAssignmentType(expected, type);
                                             cw = data.local ? CommandWord.STL : CommandWord.STM;
                                             slx.emit(cw);
                                          .)
  ';'    // Meaning: assignment
.

/*----------------------------------------------------------------------------*/

Expr<out int type>                        (. int t1; type = st.UNDEFINED; .)
= RelExpr<out t1>                         (. type = t1; .)
{                                         (.
                                             int t2;
                                             checkBoolean(t1, "&& operator");
                                             slx.emit(CommandWord.ENT, 1);
                                             slx.emit(CommandWord.REQ);
                                          .)
  "&&"
  RelExpr<out t2>                         (.
                                             checkBoolean(t2, "&& operator");
                                             slx.emit(CommandWord.ENT, 1);
                                             slx.emit(CommandWord.REQ);
                                             slx.emit(CommandWord.ADD);
                                             slx.emit(CommandWord.ENT, 2);
                                             slx.emit(CommandWord.REQ);
                                             type = st.BOOLEAN;
                                          .)
}
.

/*----------------------------------------------------------------------------*/

RelExpr<out int type>                     (. int t1; type = st.UNDEFINED; .)
= SimExpr<out t1>                         (. type = t1; .)
{                                         (. int t2; CommandWord op; .)
  RelOp<out op>                           (. checkInt(t1, "Relation operator (<, >)"); .)
  SimExpr<out t2>                         (.
                                             checkInt(t2, "Relation operator (<, >)");
                                             slx.emit(op);
                                             type = st.BOOLEAN;
                                          .)
}
.

/*----------------------------------------------------------------------------*/

SimExpr<out int type>                     (. type = st.UNDEFINED; .)
= '!'                                     (. int t; .)
  SimExpr<out t>                          (.
                                           checkBoolean(t, "! operator");
                                             slx.emit(CommandWord.NOT);
                                             type = st.BOOLEAN;
                                          .)
|                                         (. int t1; .)
  Term<out t1>                            (. type = t1; .)
{                                         (. int t2; CommandWord op; .)
  AddOp<out op>                           (. checkInt(t1, "Add (subtract) operation"); .)
  Term<out t2>                            (.
                                             checkInt(t2, "Add (subtract) operation");
                                             slx.emit(op);
                                             type = st.INTEGER;
                                          .)
}
.

/*----------------------------------------------------------------------------*/

Term<out int type>                        (. int t1; type = st.UNDEFINED; .)
= Factor<out t1>                          (. type = t1; .)
{                                         (. int t2; CommandWord op; .)
  MulOp<out op>                           (. checkInt(t1, "Multiplication (division) operation"); .)
  Factor<out t2>                          (.
                                             checkInt(t2, "Multiplication (division)");
                                             slx.emit(op);
                                             type = st.INTEGER;
                                          .)
}
.

/*----------------------------------------------------------------------------*/

Factor<out int type>                     (. type = st.UNDEFINED; .)
=
( IF (isFunctionCall()) FunctionCall<out type>
|  IF (isLengthAccess())
                                         (. IdAccessData data; .)
  IdAccess<out data> '.' "length"        (.
                                            checkArrayType(data.var.type, "array length access");
                                            slx.emit(CommandWord.LDL);
                                            slx.emit(CommandWord.LDM);
                                            type = st.INTEGER;
                                         .)
| '(' Expr<out type> ')'
|                                        (. IdAccessData data; CommandWord cw; .)
  IdAccess<out data>                     (.
                                            if (data.local) {
                                              type = data.var.type;
                                              cw = CommandWord.LDL;
                                            } else {
                                              type = st.INTEGER;
                                              cw = CommandWord.LDM;
                                            }
                                            slx.emit(cw);
                                            //type = st.INTEGER;
                                         .)
|                                        (. int val; .)
  integer                                (.
                                            val = safeParseInt(t.val);
                                            slx.emit(CommandWord.ENT, val);
                                            type = st.INTEGER;
                                         .)
| "true"                                 (. slx.emit(CommandWord.ENT, 1); type = st.BOOLEAN; .)
| "false"                                (. slx.emit(CommandWord.ENT, 0); type = st.BOOLEAN; .)
| "new" "int" '[' Expr<out type> ']'     (.
                                            checkInt(type, "array allocation size");
                                            type = st.INTEGER_ARRAY;
                                            slx.emit(CommandWord.ALC);

                                         .)
| "read" '(' ')'                         (. slx.emit(CommandWord.REA); .)
)
.

/*----------------------------------------------------------------------------*/

AddOp<out CommandWord op>                (. op = CommandWord.ADD; .)
= '+'                                    (. op = CommandWord.ADD; .)
| '-'                                    (. op = CommandWord.SUB; .)
.

/*----------------------------------------------------------------------------*/

MulOp<out CommandWord op>                (. op = CommandWord.MUL; .)
= '*'                                    (. op = CommandWord.MUL; .)
| '/'                                    (. op = CommandWord.DIV; .)
.

/*----------------------------------------------------------------------------*/

RelOp<out CommandWord op>
= '<'                                    (. op = CommandWord.RLT; .)
.

/*----------------------------------------------------------------------------*/

IdAccess<out IdAccessData data>          (.
                                            String name;
                                            SymbolTable.Variable var;
                                            data = new IdAccessData();
                                         .)
= Ident<out name>                        (.
                                            var = (SymbolTable.Variable)st.findSymbol(name);
                                            data.var = var;
                                            data.local = true;
                                            slx.emit(CommandWord.ENT, var.adr);
                                         .)
[                                        (. int type; .)
 '['                                     (.
                                            data.local = false;
                                            slx.emit(CommandWord.LDL);
                                         .)
  Expr<out type>                         (.
                                            slx.emit(CommandWord.ENT, 1);
                                            slx.emit(CommandWord.ADD);
                                            slx.emit(CommandWord.ADD);
                                         .)
  ']'
]
.

/*----------------------------------------------------------------------------*/

Ident<out String name>
= identifier                            (. name = t.val; .)
.

/*----------------------------------------------------------------------------*/

FunctionCall<out int type>              (.
                                           String name;
                                           ArrayList<Integer> parameters;
                                           SymbolTable.Function fn;
                                        .)
= Ident<out name>                       (.
                                           fn = (SymbolTable.Function)st.findSymbol(name);
                                           type = fn.type;
                                        .)
  '(' CallParams<out parameters> ')'    (.
                                           checkCallParameterTypes(fn, parameters);
                                           slx.emit(CommandWord.SFR, st.top_scope.frame_size);
                                           slx.emit(CommandWord.SBR, fn.label, parameters.size());
                                        .)
.

/*----------------------------------------------------------------------------*/

CallParams<out ArrayList<Integer>
           parameters>                  (.
                                           int type;
                                           parameters = new ArrayList<Integer>();
                                        .)
= Expr<out type>                        (. parameters.add(type); .)
{
  ',' Expr<out type>                    (. parameters.add(type); .)
}
.

/*----------------------------------------------------------------------------*/

Type<out int type>                      (. type = st.UNDEFINED; .)
= "int"                                 (. type = st.INTEGER; .)
| "int[]"                               (. type = st.INTEGER_ARRAY; .)
| "boolean"                             (. type = st.BOOLEAN; .)
.

END Compiler.
