import java.util.*;
import fi.tkk.cs.tkkcc.slx.*;

COMPILER Compiler

public Parser(Scanner s, Printer p) {
    this(s);
    this.printer = p;
}

public SymbolTable st;
public SlxProgram slx;

private Printer printer;
private int label_counter = 0;

private void checkBoolean(int type, String operation) {
  if (type != st.BOOLEAN) SemErr("type error: " +
                                 operation +
                                 " expects boolean type, got " +
                                 SymbolTable.TYPES_INVERSE.get(type));
}

private void checkInt(int type, String operation) {
  if (type != st.INTEGER) SemErr("type error: " +
                                 operation +
                                 " expects integer type, got " +
                                 SymbolTable.TYPES_INVERSE.get(type));
}

private int safeParseInt(String val) {
  try {
    return Integer.parseInt(val);
  } catch (NumberFormatException e) {
    SemErr("too large integer");
    return Integer.MAX_VALUE;
  }
}

CHARACTERS
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.

  zero          = '0'.
  nonZeroDigit  = "123456789".
  digit         = zero + nonZeroDigit .
  letter        = 'A' .. 'Z' + 'a' .. 'z' + '_' + '$'.

  char          = ANY - "'" - '\\' - cr - lf.
  stringChar    = ANY - "\"" - '\\' - cr - lf.

TOKENS
  identifier    = letter { letter | digit }.
  integer       = digit { digit }.

  colon   = ":".
  comma   = ",".
  dec     = "--".
  dot     = ".".
  inc     = "++".
  lbrace  = "{".
  lbrack  = "[".
  lpar    = "(".
  minus   = "-".
  not     = "!".
  plus    = "+".
  rbrace  = "}".
  rbrack  = "]".
  rpar    = ")".
  tilde   = "~".

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

PRODUCTIONS

/*---------------------------------------------------------------------------*/

Compiler                               (. System.out.println("Start"); .)
= MainFuncDecl                         (. slx.emit(CommandWord.HLT); .)
.

/*---------------------------------------------------------------------------*/

MainFuncDecl                           (. st.openScope(); .)
= "main"                               (. slx.emit(CommandWord.LAB, 0); .)
  FuncBody                             (. st.closeScope(); .)
.

/*---------------------------------------------------------------------------*/

FuncBody
= "begin"
  VarDecl
  StatementList
  ReturnStatement
  "end"
.

/*---------------------------------------------------------------------------*/

VarDecl                                 (. String name; int type; int var_count = 0; .)
= {
  Type<out type>
  Ident<out name>                       (. st.addVariable(name, type); var_count++; .)
  ';'
  }
.

/*---------------------------------------------------------------------------*/

ReturnStatement                          (. int type; .)
=
  "return"
  Expr<out type>
  ";"                                    // (. slx.emit(CommandWord.RET); .)
.

/*---------------------------------------------------------------------------*/

StatementList
= { Statement }
.

/*---------------------------------------------------------------------------*/

Statement
=                                         (. int type, if_end;  .)
  "if" '(' Expr<out type> ')'             (.
                                             checkBoolean(type, "if statement");
                                             if_end   = ++label_counter;
                                             slx.emit(CommandWord.JZE, if_end);
                                          .)
  "then" Statement                        (. slx.emit(CommandWord.LAB, if_end); .)
|                                         (. int type, while_start; .)
  "do"                                    (.
                                             while_start = ++label_counter;
                                             slx.emit(CommandWord.LAB, while_start);
                                          .)
  Statement
  "while" '('
  Expr<out type>                          (.
                                             checkBoolean(type, "while condition");
                                             // we don't have jump if command word,
                                             // so need to negate and use jump if not
                                             slx.emit(CommandWord.NOT);
                                             slx.emit(CommandWord.JZE, while_start);
                                          .)
  ')' ';'
|                                         (. int type; .)
  "print" '(' Expr<out type> ')' ';'      (. slx.emit(CommandWord.WRI); .)
| "begin" StatementList "end"
|                                         (. String name; int type; SymbolTable.Variable var; .)
  Ident<out name>                         (. var = (SymbolTable.Variable) st.findSymbol(name); .)
  '='                                     (. slx.emit(CommandWord.ENT, var.adr); .)
                                          // cannot assign to procedure
  Expr<out type>                          (.
                                            if (var.type == type) {
                                              slx.emit(CommandWord.STL);
                                            } else {
                                              SemErr("incompatible types: trying to assign " +
                                                     SymbolTable.TYPES_INVERSE.get(type) +
                                                     " value to " +
                                                     SymbolTable.TYPES_INVERSE.get(var.type)
                                                     + " variable");
                                            }
                                          .)
  ';'    // Meaning: assignment
.

/*---------------------------------------------------------------------------*/

Expr<out int type>                        (. int t1; type = st.UNDEFINED; .)
= RelExpr<out t1>                         (. type = t1; .)
{                                         (. int t2; .)
  "&&"                                    (. checkBoolean(t1, "&& operator"); .)
  RelExpr<out t2>                         (.
                                             checkBoolean(t2, "&& operator");
                                             slx.emit(CommandWord.REQ);
                                             slx.emit(CommandWord.ENT, 1);
                                             slx.emit(CommandWord.REQ);
                                             type = st.BOOLEAN;
                                          .)
}
.

/*---------------------------------------------------------------------------*/

RelExpr<out int type>                     (. int t1; type = st.UNDEFINED; .)
= SimExpr<out t1>                         (. type = t1; .)
{                                         (. int t2; CommandWord op; .)
  RelOp<out op>                           (. checkInt(t1, "Relation operator (<, >)"); .)
  SimExpr<out t2>                         (.
                                             checkInt(t2, "Relation operator (<, >)");
                                             slx.emit(op);
                                             type = st.BOOLEAN;
                                          .)
}
.

/*---------------------------------------------------------------------------*/

SimExpr<out int type>                     (. type = st.UNDEFINED; .)
= '!'                                     (. int t; .)
  SimExpr<out t>                          (.
                                           checkBoolean(t, "! operator");
                                             slx.emit(CommandWord.NOT);
                                             type = st.BOOLEAN;
                                          .)
|                                         (. int t1; .)
  Term<out t1>                            (. type = t1; .)
{                                         (. int t2; CommandWord op; .)
  AddOp<out op>                           (. checkInt(t1, "Add (subtract) operation"); .)
  Term<out t2>                            (.
                                             checkInt(t2, "Add (subtract) operation");
                                             slx.emit(op);
                                             type = st.INTEGER;
                                          .)
}
.

/*---------------------------------------------------------------------------*/

Term<out int type>                        (. int t1; type = st.UNDEFINED; .)
= Factor<out t1>                          (. type = t1; .)
{                                         (. int t2; CommandWord op; .)
  MulOp<out op>                           (. checkInt(t1, "Multiplication (division) operation"); .)
  Factor<out t2>                          (.
                                             checkInt(t2, "Multiplication (division)");
                                             slx.emit(op);
                                             type = st.INTEGER;
                                          .)
}
.

/*---------------------------------------------------------------------------*/

Factor<out int type>                     (. type = st.UNDEFINED; .)
=
(
  '(' Expr<out type> ')'
|                                        (. String name; SymbolTable.Variable var;.)
  IdAccess<out name>                     (.
                                            var = (SymbolTable.Variable)st.findSymbol(name);
                                            type = var.type;
                                            // slx.emit(CommandWord.ENT, var.adr);
                                            // slx.emit(CommandWord.LDM);
                                            //type = st.INTEGER;
                                         .)
|                                        (. int val; .)
  integer                                (.
                                            val = safeParseInt(t.val);
                                            slx.emit(CommandWord.ENT, val);
                                            type = st.INTEGER;
                                         .)
| "true"                                 (. slx.emit(CommandWord.ENT, 1); type = st.BOOLEAN; .)
| "false"                                (. slx.emit(CommandWord.ENT, 2); type = st.BOOLEAN; .)
| "read" '(' ')'                         (. slx.emit(CommandWord.REA); .)
)
.

/*---------------------------------------------------------------------------*/

AddOp<out CommandWord op>                 (. op = CommandWord.ADD; .)
= '+'                                     (. op = CommandWord.ADD; .)
| '-'                                     (. op = CommandWord.SUB; .)
.

/*---------------------------------------------------------------------------*/

MulOp<out CommandWord op>                 (. op = CommandWord.MUL; .)
= '*'                                     (. op = CommandWord.MUL; .)
| '/'                                     (. op = CommandWord.DIV; .)
.

/*---------------------------------------------------------------------------*/

RelOp<out CommandWord op>
= '<'                                     (. op = CommandWord.RLT; .)
.

/*---------------------------------------------------------------------------*/

IdAccess<out String name>                 (. SymbolTable.Variable var; .)
  = Ident<out name>                       (.
                                             var = (SymbolTable.Variable)st.findSymbol(name);
                                             slx.emit(CommandWord.ENT, var.adr);
                                             slx.emit(CommandWord.LDL);
                                             //slx.emit(CommandWord.STL);
                                          .)
.

/*---------------------------------------------------------------------------*/

Ident<out String name>
= identifier                              (. name = t.val; .)
.

/*---------------------------------------------------------------------------*/

Type<out int type>                        (. type = st.UNDEFINED; .)
= "int"                                   (. type = st.INTEGER; .)
| "boolean"                               (. type = st.BOOLEAN; .)
.

END Compiler.
