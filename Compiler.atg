import java.util.*;
import fi.tkk.cs.tkkcc.slx.*;

COMPILER Compiler

public SymbolTable st;
// public CodeGenerator gen;
public SlxProgram slx;

private Printer printer;
private int label_counter = 0;


/*----------------------------------------------------------------------------*
 * Helper functions:                                                          *
 * Raises an error in case of incompatible types                              *
 *----------------------------------------------------------------------------*/

private void checkBoolean(int type, String operation) {
  if (type != st.BOOLEAN) SemErr("type error: " +
                                 operation +
                                 " expects boolean type, got " +
                                 SymbolTable.TYPES_INVERSE.get(type));
}

private void checkInt(int type, String operation) {
  if (type != st.INTEGER) SemErr("type error: " +
                                 operation +
                                 " expects integer type, got " +
                                 SymbolTable.TYPES_INVERSE.get(type));
}

private int safeParseInt(String val) {
  try {
    return Integer.parseInt(val);
  } catch (NumberFormatException e) {
    SemErr("too large integer");
    return Integer.MAX_VALUE;
  }
}

/*----------------------------------------------------------------------------*
 * Functions to resolve LL(1) conflicts:                                      *
 * Used as IF ( ... ) in expressions.                                         *
 *--------------------------------------------------------------------------- */

private boolean isFunctionCall() {
  scanner.ResetPeek();

  return (la.kind == _identifier && scanner.Peek().kind == _lpar);
}

/*----------------------------------------------------------------------------*
 * Functions to keep the code cleaner                                         *
 *----------------------------------------------------------------------------*/
private SymbolTable.Function newFunction(String name, int type) {
  SymbolTable.Function fn = st.addFunction(name, type, label_counter++);
  slx.emit(CommandWord.LAB, fn.label);
  st.openScope(fn.type);
  // Address of the scope?
  return fn;
}

private void functionReturn() {
  if (st.top_scope.index == 0) return;
  slx.emit(CommandWord.RET);
}

private void checkReturnType(SymbolTable.Function fn, int type) {
  if (fn.type == type) return;

  SemErr("type error: return type of function " +
         fn.name +
         " is " +
         fn.type +
         ", got " +
         type +
         " instead");
}

private void checkAssignmentType(SymbolTable.Variable var, int type) {
  if (var.type == type) return;

  SemErr("incompatible types: trying to assign " +
         SymbolTable.TYPES_INVERSE.get(type) +
         " value to " +
         SymbolTable.TYPES_INVERSE.get(var.type)
         + " variable");
}

CHARACTERS
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.

  zero          = '0'.
  nonZeroDigit  = "123456789".
  digit         = zero + nonZeroDigit .
  letter        = 'A' .. 'Z' + 'a' .. 'z' + '_' + '$'.

  char          = ANY - "'" - '\\' - cr - lf.
  stringChar    = ANY - "\"" - '\\' - cr - lf.

TOKENS
  identifier    = letter { letter | digit }.
  integer       = digit { digit }.

  colon   = ":".
  comma   = ",".
  dec     = "--".
  dot     = ".".
  inc     = "++".
  lbrace  = "{".
  lbrack  = "[".
  lpar    = "(".
  minus   = "-".
  not     = "!".
  plus    = "+".
  rbrace  = "}".
  rbrack  = "]".
  rpar    = ")".
  tilde   = "~".

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

PRODUCTIONS

/*----------------------------------------------------------------------------*/

Compiler                               (. st.openScope(st.UNDEFINED); .)
= FuncDecl
  MainFuncDecl                         (.
                                          slx.emit(CommandWord.HLT);
                                          st.closeScope();
                                       .)
.

/*----------------------------------------------------------------------------*/

MainFuncDecl                           (. st.openScope(st.UNDEFINED); int return_type; .)
= "main"                               (. slx.emit(CommandWord.LAB, label_counter++); .)
  FuncBody<out return_type>
.

/*----------------------------------------------------------------------------*/

FuncDecl//                                (. slx.emit(CommandWord.JMP, 0) .)
=
{                                       (. int return_type; SymbolTable.Function fn; .)
  FuncHeader<out fn>
  FuncBody<out return_type>             (. checkReturnType(fn, return_type); .)
}
.

/*----------------------------------------------------------------------------*/

FuncHeader<out SymbolTable.Function fn> (. int type; .)
= Type<out type> identifier             (. fn = newFunction(t.val, type); .)
  '(' ParamList ')'                      // newFunction opens new scope
.

/*----------------------------------------------------------------------------*/

ParamList                               (. String name; int type; .)
=
[ Type<out type> Ident<out name>        (. st.addVariable(t.val, type); .)
{ ',' Type<out type> Ident<out name>    (. st.addVariable(t.val, type); .)
}
]
.

/*----------------------------------------------------------------------------*/

FuncBody<out int return_type>
= "begin"
  VarDecl
  StatementList
  ReturnStatement<out return_type>
  "end"                                 (. st.closeScope(); .)
.

/*----------------------------------------------------------------------------*/

VarDecl                                 (. String name; int type; .)
=
{ Type<out type>
  Ident<out name>                       (. st.addVariable(name, type); .)
  ';'
}                                       // TODO: check the frame size?
.

/*----------------------------------------------------------------------------*/

ReturnStatement<out int type>
= "return"
  Expr<out type>
  ";"                                    (. functionReturn(); .)
.

/*----------------------------------------------------------------------------*/

StatementList
= { Statement }
.

/*----------------------------------------------------------------------------*/

Statement
=                                         (. int type, if_end; .)
  "if" '(' Expr<out type> ')'             (.
                                             checkBoolean(type, "if statement");
                                             if_end   = label_counter++;
                                             slx.emit(CommandWord.JZE, if_end);
                                          .)
  "then" Statement                        (. slx.emit(CommandWord.LAB, if_end); .)
|                                         (. int type, while_start; .)
  "do"                                    (.
                                             while_start = label_counter++;
                                             slx.emit(CommandWord.LAB, while_start);
                                          .)
  Statement
  "while" '('
  Expr<out type>                          (.
                                             checkBoolean(type, "while condition");
                                             // we don't have jump if command word,
                                             // so need to negate and use jump if not
                                             slx.emit(CommandWord.NOT);
                                             slx.emit(CommandWord.JZE, while_start);
                                          .)
  ')' ';'
|                                         (. int type; .)
  "print" '(' Expr<out type> ')' ';'      (. slx.emit(CommandWord.WRI); .)
| "begin" StatementList "end"
|                                         (. String name; int type; SymbolTable.Variable var; .)
  IdAccess<out name>                      (. var = (SymbolTable.Variable) st.findSymbol(name); .)
  '='                                     (. slx.emit(CommandWord.ENT, var.adr); .)
                                          // cannot assign to procedure
  Expr<out type>                          (.
                                             checkAssignmentType(var, type);

                                             slx.emit(CommandWord.STL);
                                          .)
  ';'    // Meaning: assignment
.

/*----------------------------------------------------------------------------*/

Expr<out int type>                        (. int t1; type = st.UNDEFINED; .)
= RelExpr<out t1>                         (. type = t1; .)
{                                         (. int t2; .)
  "&&"                                    (. checkBoolean(t1, "&& operator"); .)
  RelExpr<out t2>                         (.
                                             checkBoolean(t2, "&& operator");
                                             slx.emit(CommandWord.REQ);
                                             slx.emit(CommandWord.ENT, 1);
                                             slx.emit(CommandWord.REQ);
                                             type = st.BOOLEAN;
                                          .)
}
.

/*----------------------------------------------------------------------------*/

RelExpr<out int type>                     (. int t1; type = st.UNDEFINED; .)
= SimExpr<out t1>                         (. type = t1; .)
{                                         (. int t2; CommandWord op; .)
  RelOp<out op>                           (. checkInt(t1, "Relation operator (<, >)"); .)
  SimExpr<out t2>                         (.
                                             checkInt(t2, "Relation operator (<, >)");
                                             slx.emit(op);
                                             type = st.BOOLEAN;
                                          .)
}
.

/*----------------------------------------------------------------------------*/

SimExpr<out int type>                     (. type = st.UNDEFINED; .)
= '!'                                     (. int t; .)
  SimExpr<out t>                          (.
                                           checkBoolean(t, "! operator");
                                             slx.emit(CommandWord.NOT);
                                             type = st.BOOLEAN;
                                          .)
|                                         (. int t1; .)
  Term<out t1>                            (. type = t1; .)
{                                         (. int t2; CommandWord op; .)
  AddOp<out op>                           (. checkInt(t1, "Add (subtract) operation"); .)
  Term<out t2>                            (.
                                             checkInt(t2, "Add (subtract) operation");
                                             slx.emit(op);
                                             type = st.INTEGER;
                                          .)
}
.

/*----------------------------------------------------------------------------*/

Term<out int type>                        (. int t1; type = st.UNDEFINED; .)
= Factor<out t1>                          (. type = t1; .)
{                                         (. int t2; CommandWord op; .)
  MulOp<out op>                           (. checkInt(t1, "Multiplication (division) operation"); .)
  Factor<out t2>                          (.
                                             checkInt(t2, "Multiplication (division)");
                                             slx.emit(op);
                                             type = st.INTEGER;
                                          .)
}
.

/*----------------------------------------------------------------------------*/

Factor<out int type>                     (. type = st.UNDEFINED; .)
=
( IF (isFunctionCall()) FunctionCall     (..)
| IF (true) identifier '.' "length"      (..)
  '(' Expr<out type> ')'
|                                        (. String name; SymbolTable.Variable var;.)
  IdAccess<out name>                     (.
                                            var = (SymbolTable.Variable)st.findSymbol(name);
                                            type = var.type;
                                            // slx.emit(CommandWord.ENT, var.adr);
                                            // slx.emit(CommandWord.LDM);
                                            //type = st.INTEGER;
                                         .)
|                                        (. int val; .)
  integer                                (.
                                            val = safeParseInt(t.val);
                                            slx.emit(CommandWord.ENT, val);
                                            type = st.INTEGER;
                                         .)
| "true"                                 (. slx.emit(CommandWord.ENT, 1); type = st.BOOLEAN; .)
| "false"                                (. slx.emit(CommandWord.ENT, 2); type = st.BOOLEAN; .)
| "new" "int" '[' Expr<out type> ']'     (.
                                            checkInt(type, "array allocation size");
                                            type = st.INTEGER_ARRAY;
                                            slx.emit(CommandWord.ALC);
                                            slx.emit(CommandWord.STL);

                                         .)
| "read" '(' ')'                         (. slx.emit(CommandWord.REA); .)
)
.

/*----------------------------------------------------------------------------*/

AddOp<out CommandWord op>                (. op = CommandWord.ADD; .)
= '+'                                    (. op = CommandWord.ADD; .)
| '-'                                    (. op = CommandWord.SUB; .)
.

/*----------------------------------------------------------------------------*/

MulOp<out CommandWord op>                (. op = CommandWord.MUL; .)
= '*'                                    (. op = CommandWord.MUL; .)
| '/'                                    (. op = CommandWord.DIV; .)
.

/*----------------------------------------------------------------------------*/

RelOp<out CommandWord op>
= '<'                                    (. op = CommandWord.RLT; .)
.

/*----------------------------------------------------------------------------*/

IdAccess<out String name>                (. SymbolTable.Variable var; .)
= Ident<out name>                        (.
                                            var = (SymbolTable.Variable)st.findSymbol(name);
                                            slx.emit(CommandWord.ENT, var.adr);
                                            slx.emit(CommandWord.LDL);
                                         .)
[                                        (. int type; .)
  '[' Expr<out type> ']'
]
.

/*----------------------------------------------------------------------------*/

Ident<out String name>
= identifier                             (. name = t.val; .)
.

/*----------------------------------------------------------------------------*/

FunctionCall
= identifier '(' CallParams ')'
.

/*----------------------------------------------------------------------------*/

CallParams                               (. int type; .)
= Expr<out type>
{ ',' Expr<out type> }
.

/*----------------------------------------------------------------------------*/

Type<out int type>                       (. type = st.UNDEFINED; .)
= "int"                                  (. type = st.INTEGER; .)
| "int[]"                                (. type = st.INTEGER_ARRAY; .)
| "boolean"                              (. type = st.BOOLEAN; .)
.

END Compiler.
